<!DOCTYPE html>
<html lang="en">
<head>
<title>Boyer Moore</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="Unicat project">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="styles/bootstrap4/bootstrap.min.css">
<link href="plugins/font-awesome-4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="plugins/OwlCarousel2-2.2.1/owl.carousel.css">
<link rel="stylesheet" type="text/css" href="plugins/OwlCarousel2-2.2.1/owl.theme.default.css">
<link rel="stylesheet" type="text/css" href="plugins/OwlCarousel2-2.2.1/animate.css">
<link rel="stylesheet" type="text/css" href="styles/main_styles.css">
<link rel="stylesheet" type="text/css" href="styles/responsive.css">
</head>
<style>
input[type=text], select {
width: 100%;
padding: 12px 20px;
margin: 8px 0;
display: inline-block;
border: 1px solid #ccc;
border-radius: 4px;
box-sizing: border-box;
}

#divv {
border-radius: 5px;
background-color: #f2f2f2;
padding: 20px;
}
</style>
<body>

<div class="super_container">

	<!-- Header -->

	<header class="header">

		<!-- Top Bar -->
		<div class="top_bar">
			<div class="top_bar_container">
				<div class="container">
					<div class="row">
						<div class="col">
							<div class="top_bar_content d-flex flex-row align-items-center justify-content-start">
								<ul class="top_bar_contact_list">
									<li><div class="question">String Matching Algorithm</div></li>
								</ul>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>

		<!-- Header Content -->
		<div class="header_container">
			<div class="container">
				<div class="row">
					<div class="col">
						<div class="header_content d-flex flex-row align-items-center justify-content-start">
							<div class="logo_container">
								<a href="#">
									<div class="logo_text">Boyer<span> Moore</span></div>
								</a>
							</div>
							<nav class="main_nav_contaner ml-auto">
							</nav>

						</div>
					</div>
				</div>
			</div>
		</div>

		<!-- Header Search Panel -->
		<div class="header_search_container">
			<div class="container">
				<div class="row">
					<div class="col">
						<div class="header_search_content d-flex flex-row align-items-center justify-content-end">
							<form action="#" class="header_search_form">
								<input type="search" class="search_input" placeholder="Search" required="required">
								<button class="header_search_button d-flex flex-column align-items-center justify-content-center">
									<i class="fa fa-search" aria-hidden="true"></i>
								</button>
							</form>
						</div>
					</div>
				</div>
			</div>
		</div>
	</header>

	<!-- Menu -->

	<div class="menu d-flex flex-column align-items-end justify-content-start text-right menu_mm trans_400">
		<div class="menu_close_container"><div class="menu_close"><div></div><div></div></div></div>
		<div class="search">
			<form action="#" class="header_search_form menu_mm">
				<input type="search" class="search_input menu_mm" placeholder="Search" required="required">
				<button class="header_search_button d-flex flex-column align-items-center justify-content-center menu_mm">
					<i class="fa fa-search menu_mm" aria-hidden="true"></i>
				</button>
			</form>
		</div>
		<nav class="menu_nav">
			<ul class="menu_mm">
				<li class="menu_mm"><a href="index.html">Home</a></li>
				<li class="menu_mm"><a href="#">About</a></li>
				<li class="menu_mm"><a href="#">Courses</a></li>
				<li class="menu_mm"><a href="#">Blog</a></li>
				<li class="menu_mm"><a href="#">Page</a></li>
				<li class="menu_mm"><a href="contact.html">Contact</a></li>
			</ul>
		</nav>
	</div>

<br>
<br>
<br>
<br>
<br>

	<!-- Features -->

	<div class="features">
		<div class="container">
			<div class="row">
				<div class="col">
					<div class="section_title_container text-center">
						<h2 class="section_title">Boyer Moore Algorithm</h2>
						<div class="section_subtitle"><p>It preporcesses the pattern and creates different arrays for both heuristics. At every step, it slides the pattern by max of the slides suggested by the two heuristics. So it uses best of the two heuristics at every step.</p></div>
					</div>
				</div>
			</div>
			<br>
			<br>
			<p>Boyer Moore algorithm starts matching from the last character of the pattern. It preporcesses the pattern and creates different arrays for both heuristics. At every step, it slides the pattern by max of the slides suggested by the two heuristics. So it uses best of the two heuristics at every step.</p>
			<p>Boyer Moore is a combination of following two approaches.</p>
			<p>1) Bad Character Heuristic</p>
			<p>2) Good Suffix Heuristic</p>
			<br>
			<p>An efficient string matching algorithm that is the standard benchmark
for practical string-search literature is the Boyer-Moore algorithm. The algorithm is mainly used in computer science. In general, it runs
faster if the pattern is longer - a feature that is extremely rare in the field
of algorithms. The reason for that is that the algorithm seems to match on
the tail of the pattern rather than the head, and to skip along the text in
jumps of multiple characters rather than searching every single character in
the text.</p>
<p>A significantly faster string searching method is to scan the pattern
from right to left when trying to match it against the text. This can be
easily seen on the example, where P = BAABBAA, assuming there are
matches on the sixth and seventh character, but not on the fifth. Notice that
the pattern can be immediately slided seven positions to the right and can
move on checking the fourteenth character in the text. This can be done
because the partial match XAA, where X is not equal to B, does not appear
elsewhere in the pattern. The pattern could appear somewhere in the text
later, so there is a need to remember the position to restart the searching
method if there is a need.</p>
<p>Another example of Boyer-Moore shifting and searching, is shown in
Figure 1 where the text (or often called ”haystack”) is T = F INDINAHAY ST ACKNEEDLE and the ”needle” (or the pattern)
is P = NEEDLE.</p>
<p>The comparison starts from the rightmost character E
and it is compared with character N on the fifth position in the text. Since
N appears in the pattern, the pattern is slided five positions to the right to
line up the N in the text with the rightmost N in the pattern. The next
comparison is made with the rightmost E in the pattern with the character
S on the tenth position in the text. The difference with the mismatched S is
because S does not appear in the pattern so the pattern is slided six positions
to the right. The rightmost E in the pattern is matched with the character
on position 16, where a mismatch exists. N at position 15 is discovered and
the pattern is slid four positions. Finally, moving from right to left in the
text at position 20, the searched pattern is discovered within the text. The
algorithm uses only four comparisons to find the suitable pattern, which is
much better than with the naive algorithm</p>
<br>
<br>
<img src="images/bm1.png" alt="img" width="700" height="300">
<p>Figure 1: Simple example for Boyer-Moore algorithm</p>
<br>
<br>
<p> One of the main reasons for the popularity of the Boyer-Moore algorithm is in its preprocessing. The algorithm is suitable for applications when
the pattern is much shorter than the text. The condition is basically fulfilled
in almost every searching case, which is why the algorithm often is so used
in practice and theory.</p>
<p>There are two variants to perform shifting and preprocessing based on rules
called: the Bad Character Rule (BCR) and the Good Suffix Rule (GSR).</p>
<br>
<p>Each rule has its own advantages and disadvantages, so their names ”good”
and ”bad”, do not mean that the one is actually better than the other.</p>
<p><b>The Bad Character Rule (BCR)</b></p>
<br>
<h5>Definition :</h5>
<p><i>This rule reviews the character in the text T where
comparison failed. When the next occurrence of the character to the left
is found in the pattern P, then a shift that brings that occurrence in line
with the mismatched occurrence in T is proposed. If the mismatched
character does not occur to the left in P, a new shift is proposed that
moves entire P past the point of mismatch.</i></p>
<br>
<br>
<img src="images/bm2.png" alt="img" width="700" height="300">
<p><i>Figure 2: Example of BCR, where b is a mismatched character. Skip alignments until (a) b matches its opposite in P or (b) P moves past b.</i></p>
<br>
<br>
<p>To estimate BCR’s time complexity, we can use a 2D array where
the first dimension is indexed by the index of the character c in the
alphabet, and the second dimension is indexed by the index i from the
pattern. BCR will return the occurrence c of P with the index j < i
(or -1 if there is a mismatch). The time complexity of BCR is thus
O(1), a constant, which is in practice the best amount the searching
algorithms can have. The space complexity of BCR is O(k*n), where
k is the size (the number of characters) of the alphabet.</p>
<br>
<p><b>The Good Suffix Rule (GSR)</b></p>
<p>This rule is the advantage of the Boyer-Moore algorithm, searching
from right to left.</p>
<br>
<h5>Definition :</h5>
<p><i>Suppose that for a given alignment of P and T, a
substring t of T matches a suffix of P, but a mismatch occurs at the
next comparison to the left. Then find, if it exists, the rightmost copy
t’ of t in P such that t’ is not a suffix of P and the character to the left
of t’ in P differs from the character to the left of t in P. Shift P to the
right so that substring t’ in P aligns with substring t in T. If t’ does
not exist, then shift the left end of P past the left end of t in T by the
least amount so that a prefix of the shifted pattern matches a suffix of
t in T. If no such shift is possible, then shift P by x (x is the length of
the suffix) places to the right. If an occurrence of P is found, then shift
P by the least amount so that a proper prefix of the shifted P matches
a suffix of the occurrence of P in T. If no such shift is possible, then
shift P by x places, that is, shift P past t.</i></p>
<br>
<br>
<img src="images/bm3.png" alt="img" width="600" height="500">
<p><i>Figure 3: Example for GSR, where t is a substring of T and matches a
suffix of P. Skip alignments until t matches the opposite character in P (a),
a prefix of P matches a suffix of t (b) or P moves past the first matching
substring t(c).</i></p>
<br>
<br>
<p>To determine GSR’s time complexity of the processing, we need two
arrays: L for the general case, and H for either when the general returns
a meaningless result or a match occurs.
It is known that for each i in L, the index i is the largest position less
than n and it is proven that the pattern P[i, ..., n] matches a suffix
P[1, ..., L[i]] and it is not equal to P[i − 1]. If this condition is not
satisfied, current index in the array is equal to zero. The index in H
is determined as the length of the largest suffix in P, which is at the
same time a prefix of P.</p>
<p>All of this leads to a linear time and space complexity, O(n), where n
is the length of the text.</p>
<br>
<br>
<p>The pseudocode of the algorithm contains two functions in addition to
the main one: the function for computing the good suffix and the function for
computing the last occurrence. The input consists of the substring/pattern,
the text, and an alphabet Σ. Here is the pseudocode.</p>
<br>
<h5>Pseudocode :</h5>
<br>
<pre>BOYER-MOORE ALGORITHM(P,T,Sigma)
m = length(P)
n = length(T)
lambda = compute last occurrence(P,m,Sigma)
gamma = compute good suffix(P,m)
s = 0
while s <= n-m
do j = m
while j>0 and P[j] = T[s+j]
do j = j-1
if j = 0
then print "The pattern occurs at shift" s
s = s + gamma[0]
else s = s + max(gamma[j],lambda[T[s+j]])
COMPUTE LAST OCCURRENCE(P,m,Sigma)
for each a in Sigma
do lambda[a] = 0
for j = 1 to m
do lambda[P[j]] = j
return
COMPUTE GOOD SUFFIX(P,m)
pi = compute prefix function(P)
P’ = reverse(P)
pi’ = compute prefix function(P’)
for j = 0 to m
do gamma[j] = m- pi[m]
for l = 1 to m
do j = m - pi’[l]
if gamma[j] > l - pi’[l]
then gamma[j] = l - pi’[l]
return</pre>
<br>
<h4>Boyre Moore Implementation:</h4>
<div id="divv">
  <form>
    <label for="fname">Input String :</label>
    <input type="text" id="in" name="input" placeholder="Enter a String (Eg. Monkey eats bananas)">

    <label for="lname">Input Substring :</label>
    <input type="text" id="in2" name="input" placeholder="Enter a Substring (Eg. eats)">
    <br>
		<br>
		<h4 id="app"></h4>

		<br>
		<br>
    <p class="btn btn-primary" id="submitt">Match</p>
  </form>
</div>
		</div>
	</div>



	<!-- Newsletter -->

	<div class="newsletter">
		<div class="newsletter_background parallax-window" data-parallax="scroll" data-image-src="images/newsletter.jpg" data-speed="0.8"></div>
		<div class="container">
			<div class="row">
				<div class="col">
					<div class="newsletter_container d-flex flex-lg-row flex-column align-items-center justify-content-start">

						<!-- Newsletter Content -->
						<div class="newsletter_content text-lg-left text-center">
							<div class="newsletter_title">Complexity :</div>
							<div class="newsletter_subtitle">To sum up, the algorithm’s time complexity is O(n+m), if and only if the
pattern does not appear in the text. However, this is not the best case scenario, because the main aim of this algorithm is to find an existing substring
in the text. The worst case time complexity when the substring does appear
in the text is O(n*m). Although this is the same time complexity as the
time complexity of the naive algorithm, Boyer-Moore algorithm is in practice better due to its searching from tail to head, preprocessing, omitting
unnecessary comparisons, etc.</div>
						</div>

					</div>
				</div>
			</div>
		</div>
	</div>

	<!-- Footer -->

	<footer class="footer">
		<div class="footer_background" style="background-image:url(images/footer_background.png)"></div>
		<div class="container">
			<div class="row footer_row">
				<div class="col">
					<div class="footer_content">
						<div class="row">

							<div class="col-lg-3 footer_col">

								<!-- Footer About -->
								<div class="footer_section footer_about">
									<div class="footer_logo_container">
										<a href="#">
											<div class="footer_logo_text">Abo<span>ut</span></div>
										</a>
									</div>
									<div class="footer_about_text">
										<p>To help understand how a pattern is searched in a string over a substring when provided using boyer moore algorithm and study its complexity.</p>
									</div>
								</div>

							</div>

							<div class="col-lg-3 footer_col">

								<!-- Footer Contact -->
								<div class="footer_section footer_contact">
								</div>

							</div>

							<div class="col-lg-3 footer_col">

								<!-- Footer links -->
								<div class="footer_section footer_links">
								</div>

							</div>

							<div class="col-lg-3 footer_col clearfix">

								<!-- Footer links -->
								<div class="footer_section footer_mobile">
									<p style="color: white;">Presented by Mrs. Disha Deotale</p>
								</div>

							</div>

						</div>
					</div>
				</div>
			</div>

			<div class="row copyright_row">
				<div class="col">
					<div class="copyright d-flex flex-lg-row flex-column align-items-center justify-content-start">
						<div class="cr_text">
Copyright &copy;<script>document.write(new Date().getFullYear());</script> All rights reserved</div>
						<div class="ml-lg-auto cr_links">
							<ul class="cr_list">
								<li><a href="#">www.boyermoore.ml</a></li>
							</ul>
						</div>
					</div>
				</div>
			</div>
		</div>
	</footer>
</div>

<script src="js/jquery-3.2.1.min.js"></script>
<script src="styles/bootstrap4/popper.js"></script>
<script src="styles/bootstrap4/bootstrap.min.js"></script>
<script src="plugins/greensock/TweenMax.min.js"></script>
<script src="plugins/greensock/TimelineMax.min.js"></script>
<script src="plugins/scrollmagic/ScrollMagic.min.js"></script>
<script src="plugins/greensock/animation.gsap.min.js"></script>
<script src="plugins/greensock/ScrollToPlugin.min.js"></script>
<script src="plugins/OwlCarousel2-2.2.1/owl.carousel.js"></script>
<script src="plugins/easing/easing.js"></script>
<script src="plugins/parallax-js-master/parallax.min.js"></script>
<script src="js/custom.js"></script>
<script>
$(document).ready(function(){
// Add smooth scrolling to all links
$("#submitt").on('click', function(event) {

	var x = document.getElementById("in").value;
	var y = document.getElementById("in2").value;
	if (x==null || x=="" || y==null || y=="")
	{
		alert("Please provide an input and do not leave any field blank.");
	}
	else {
		var n = x.indexOf(y);
		document.getElementById("app").innerHTML = "The substring was matched at position "+n;
	}
});
});
</script>
</body>
</html>
